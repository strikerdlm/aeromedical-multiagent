---
description: When asked about the flowise API
globs: 
alwaysApply: false
---
# Enhanced Flowise API Integration Rules

## Overview
FlowiseAI is a low-code LLM orchestration tool built on top of LangChain and LlamaIndex. This document provides comprehensive rules for integrating with Flowise APIs using multiple chatflow IDs.

## Base Configuration

### API Base URLs
- **Production**: `https://cloud.flowiseai.com/`
- **API Base Path**: `/api/v1`

### Authentication
```python
# All API calls require Bearer token authentication
headers = {
    "Authorization": "Bearer wDwjOLUaht_AkEgpyk1c8zw3ApNe7vdy69_uBbdeMCU",
    "Content-Type": "application/json"
}
```

## Multiple Chatflow Management

### Chatflow ID Examples
Here are chatflow IDs:

```python
CHATFLOW_IDS = {
    # Medical and Research Chatflows
    "physiology_rag": "d0bf0d84-1343-4f3b-a887-780d20f9e3c6",
    "nasa_hrp": "a7549a33-2326-4cab-b4db-bd39365e2c7d", 
    "flight_surgeon": "dcdb1c81-a027-4876-81bb-5535d22a5bc0",
    "drone_pilot": "43cfb238-4864-4599-866e-d8ec24235203",
    
    # Research Database Chatflows
    "pubmed": "a497e478-4670-4d43-82d6-1ccbfb842ee2",
    "arxiv": "4bcf45ee-a442-4e14-a584-97468c234d9c",
    "crossref": "db428808-722e-4189-8ade-0740e035219d",
    
    # Clinical Resources
    "clinical_textbooks": "ad449a15-f9a1-4c53-9317-36d995474fe1",
    "five_minute_consult": "3e400cbb-9c0f-4925-9b4e-d1d51f55d369",
    
    # Advanced AI Agents (2025)
    "deep_research": "43677137-d307-4ff4-96c9-5019b6e10879",
    "aeromedical_risk": "c7a56c4b-a8a2-423d-ad6c-e49a7003e8cb",
    "agentic_rag": "23a968e1-5185-43df-b5d1-1cbe8e3f2522"
}

# Corresponding configurations for each chatflow
CHATFLOW_CONFIGS = {
    "physiology_rag": {
        "sessionId": "physiology_session",
        "returnSourceDocuments": True,
        "streaming": True,
        "overrideConfig": {
            "temperature": 0.3,  # Lower temperature for medical accuracy
            "maxTokens": 2000
        }
    },
    "nasa_hrp": {
        "sessionId": "nasa_session", 
        "returnSourceDocuments": True,
        "streaming": True,
        "overrideConfig": {
            "temperature": 0.2,  # Very low for NASA standards
            "maxTokens": 1500
        }
    },
    "flight_surgeon": {
        "sessionId": "flight_surgeon_session",
        "returnSourceDocuments": True,
        "streaming": True,
        "overrideConfig": {
            "temperature": 0.3,
            "maxTokens": 2000
        }
    },
    "drone_pilot": {
        "sessionId": "drone_session",
        "returnSourceDocuments": True,
        "streaming": True,
        "overrideConfig": {
            "temperature": 0.4,
            "maxTokens": 1500
        }
    },
    "pubmed": {
        "sessionId": "pubmed_session",
        "returnSourceDocuments": True,
        "streaming": False,  # Academic research might prefer complete responses
        "overrideConfig": {
            "temperature": 0.1,  # Very factual for medical research
            "maxTokens": 3000
        }
    },
    "arxiv": {
        "sessionId": "arxiv_session",
        "returnSourceDocuments": True,
        "streaming": False,
        "overrideConfig": {
            "temperature": 0.2,
            "maxTokens": 3000
        }
    },
    "crossref": {
        "sessionId": "crossref_session",
        "returnSourceDocuments": True,
        "streaming": False,
        "overrideConfig": {
            "temperature": 0.1,
            "maxTokens": 2000
        }
    },
    "clinical_textbooks": {
        "sessionId": "textbooks_session",
        "returnSourceDocuments": True,
        "streaming": True,
        "overrideConfig": {
            "temperature": 0.2,
            "maxTokens": 2500
        }
    },
    "five_minute_consult": {
        "sessionId": "consult_session",
        "returnSourceDocuments": True,
        "streaming": True,
        "overrideConfig": {
            "temperature": 0.3,
            "maxTokens": 1000  # Quick consults
        }
    },
    "deep_research": {
        "sessionId": "research_session",
        "returnSourceDocuments": True,
        "streaming": True,
        "overrideConfig": {
            "temperature": 0.4,  # More creative for research
            "maxTokens": 4000
        }
    },
    "aeromedical_risk": {
        "sessionId": "risk_session",
        "returnSourceDocuments": True,
        "streaming": True,
        "overrideConfig": {
            "temperature": 0.2,  # Conservative for risk assessment
            "maxTokens": 2000
        }
    },
    "agentic_rag": {
        "sessionId": "agentic_session",
        "returnSourceDocuments": True,
        "streaming": True,
        "overrideConfig": {
            "temperature": 0.3,
            "maxTokens": 3000
        }
    }
}

# Environment variables format
CHATFLOW_ENV_VARS = """
# Medical and Research Chatflows
CHATFLOW_PHYSIOLOGY_RAG=d0bf0d84-1343-4f3b-a887-780d20f9e3c6
CHATFLOW_NASA_HRP=a7549a33-2326-4cab-b4db-bd39365e2c7d
CHATFLOW_FLIGHT_SURGEON=dcdb1c81-a027-4876-81bb-5535d22a5bc0
CHATFLOW_DRONE_PILOT=43cfb238-4864-4599-866e-d8ec24235203

# Research Database Chatflows
CHATFLOW_PUBMED=a497e478-4670-4d43-82d6-1ccbfb842ee2
CHATFLOW_ARXIV=4bcf45ee-a442-4e14-a584-97468c234d9c
CHATFLOW_CROSSREF=db428808-722e-4189-8ade-0740e035219d

# Clinical Resources
CHATFLOW_CLINICAL_TEXTBOOKS=ad449a15-f9a1-4c53-9317-36d995474fe1
CHATFLOW_FIVE_MINUTE_CONSULT=3e400cbb-9c0f-4925-9b4e-d1d51f55d369

# Advanced AI Agents (2025)
CHATFLOW_DEEP_RESEARCH=43677137-d307-4ff4-96c9-5019b6e10879
CHATFLOW_AEROMEDICAL_RISK=c7a56c4b-a8a2-423d-ad6c-e49a7003e8cb
CHATFLOW_AGENTIC_RAG=23a968e1-5185-43df-b5d1-1cbe8e3f2522
"""

# Usage example with your specific chatflows
def route_medical_query(query_type: str, question: str):
    """Route medical queries to appropriate specialized chatflows"""
    
    medical_routing = {
        "physiology": "physiology_rag",
        "nasa": "nasa_hrp", 
        "flight_medicine": "flight_surgeon",
        "aviation": "drone_pilot",
        "research": "pubmed",
        "papers": "arxiv",
        "citations": "crossref",
        "clinical": "clinical_textbooks",
        "quick_consult": "five_minute_consult",
        "deep_analysis": "deep_research",
        "risk_assessment": "aeromedical_risk",
        "advanced_rag": "agentic_rag"
    }
    
    if query_type not in medical_routing:
        return f"Available query types: {', '.join(medical_routing.keys())}"
    
    chatflow_key = medical_routing[query_type]
    chatflow_id = CHATFLOW_IDS[chatflow_key]
    config = CHATFLOW_CONFIGS[chatflow_key]
    
    # Use the enhanced API client from the previous rules
    return send_message(chatflow_id, question, config)

# Specialized medical chatflow router
class MedicalFlowiseRouter(FlowiseMultiChatRouter):
    def __init__(self, base_url: str, api_key: str):
        super().__init__(base_url, api_key)
        self.chatflows = CHATFLOW_IDS
        self.configs = CHATFLOW_CONFIGS
    
    def consult_pubmed(self, query: str):
        """Query PubMed medical literature"""
        return self.route_message("pubmed", query)
    
    def consult_nasa_hrp(self, query: str):
        """Query NASA Human Research Program data"""
        return self.route_message("nasa_hrp", query)
    
    def flight_medical_consult(self, query: str):
        """Consult flight surgeon knowledge base"""
        return self.route_message("flight_surgeon", query)
    
    def assess_aeromedical_risk(self, query: str):
        """Assess aeromedical risks"""
        return self.route_message("aeromedical_risk", query)
    
    def deep_research_analysis(self, query: str):
        """Perform deep research analysis"""
        return self.route_streaming_message("deep_research", query)

## Core API Endpoints

### 1. Chatflow Management

#### List All Chatflows
```python
def get_all_chatflows():
    """Retrieve all available chatflows"""
    url = f"{BASE_URL}/api/v1/chatflows"
    response = requests.get(url, headers=headers)
    return response.json()
```

#### Get Specific Chatflow
```python
def get_chatflow(chatflow_id: str):
    """Get details of a specific chatflow"""
    url = f"{BASE_URL}/api/v1/chatflows/{chatflow_id}"
    response = requests.get(url, headers=headers)
    return response.json()
```

#### Get Chatflow by API Key
```python
def get_chatflow_by_apikey(api_key: str):
    """Retrieve chatflow using API key"""
    url = f"{BASE_URL}/api/v1/chatflows/apikey/{api_key}"
    response = requests.get(url, headers=headers)
    return response.json()
```

### 2. Prediction API (Main Chat Interface)

#### Standard Prediction
```python
def send_message(chatflow_id: str, question: str, config: dict = None):
    """Send message to specific chatflow"""
    url = f"{BASE_URL}/api/v1/prediction/{chatflow_id}"
    
    payload = {
        "question": question,
        "streaming": False
    }
    
    # Add configuration if provided
    if config:
        payload.update(config)
    
    response = requests.post(url, headers=headers, json=payload)
    return response.json()
```

#### Streaming Prediction
```python
def send_streaming_message(chatflow_id: str, question: str, config: dict = None):
    """Send streaming message to specific chatflow"""
    url = f"{BASE_URL}/api/v1/prediction/{chatflow_id}"
    
    payload = {
        "question": question,
        "streaming": True
    }
    
    if config:
        payload.update(config)
    
    response = requests.post(url, headers=headers, json=payload, stream=True)
    
    for line in response.iter_lines():
        if line:
            line = line.decode('utf-8')
            if line.startswith('data: '):
                data = line[6:]  # Remove 'data: ' prefix
                if data != '[DONE]':
                    try:
                        yield json.loads(data)
                    except json.JSONDecodeError:
                        yield data
```

### 3. Multi-Chatflow Router
```python
class FlowiseMultiChatRouter:
    def __init__(self, base_url: str, api_key: str):
        self.base_url = base_url
        self.headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
        self.chatflows = CHATFLOW_IDS
        self.configs = CHATFLOW_CONFIGS
    
    def route_message(self, flow_type: str, message: str, **kwargs):
        """Route message to appropriate chatflow based on type"""
        if flow_type not in self.chatflows:
            raise ValueError(f"Unknown flow type: {flow_type}")
        
        chatflow_id = self.chatflows[flow_type]
        config = self.configs.get(flow_type, {})
        
        # Merge additional config
        config.update(kwargs)
        
        return self.send_message(chatflow_id, message, config)
    
    def route_streaming_message(self, flow_type: str, message: str, **kwargs):
        """Route streaming message to appropriate chatflow"""
        if flow_type not in self.chatflows:
            raise ValueError(f"Unknown flow type: {flow_type}")
        
        chatflow_id = self.chatflows[flow_type]
        config = self.configs.get(flow_type, {})
        config.update(kwargs)
        config["streaming"] = True
        
        return self.send_streaming_message(chatflow_id, message, config)
```

## Streaming Event Types

### Event Structure
```python
# Streaming events follow this structure:
{
    "event": "token|start|end|error|metadata|sourceDocuments|usedTools",
    "data": "content or object"
}
```

### Event Handlers
```python
def handle_stream_events(stream_response):
    """Handle different types of streaming events"""
    for chunk in stream_response:
        event = chunk.get("event")
        data = chunk.get("data")
        
        if event == "start":
            print("🚀 Stream started")
        elif event == "token":
            print(data, end="", flush=True)  # Print tokens as they arrive
        elif event == "end":
            print("\n✅ Stream completed")
        elif event == "error":
            print(f"❌ Error: {data}")
        elif event == "metadata":
            print(f"📋 Metadata: {data}")
        elif event == "sourceDocuments":
            print(f"📚 Sources: {data}")
        elif event == "usedTools":
            print(f"🔧 Tools used: {data}")
```

## Advanced Configuration Options

### Session Management
```python
def create_session_config(user_id: str, session_type: str = "default"):
    """Create session configuration for user tracking"""
    return {
        "sessionId": f"{session_type}_{user_id}_{int(time.time())}",
        "chatId": f"chat_{user_id}",
        "returnSourceDocuments": True,
        "overrideConfig": {
            "sessionId": f"{session_type}_{user_id}"
        }
    }
```

### Upload Handling
```python
def send_message_with_upload(chatflow_id: str, question: str, file_data: bytes, filename: str):
    """Send message with file upload"""
    url = f"{BASE_URL}/api/v1/prediction/{chatflow_id}"
    
    # Prepare multipart data
    files = {
        'files': (filename, file_data, 'application/octet-stream')
    }
    
    data = {
        'question': question,
        'uploads': True
    }
    
    headers_no_content_type = {
        "Authorization": headers["Authorization"]
    }
    
    response = requests.post(url, headers=headers_no_content_type, data=data, files=files)
    return response.json()
```

## Error Handling and Retry Logic

### Robust Error Handling
```python
import time
from typing import Optional, Dict, Any

class FlowiseAPIError(Exception):
    pass

def safe_api_call(func, max_retries: int = 3, delay: float = 1.0, **kwargs):
    """Make API call with retry logic"""
    for attempt in range(max_retries):
        try:
            response = func(**kwargs)
            
            if hasattr(response, 'status_code'):
                if response.status_code == 200:
                    return response.json() if hasattr(response, 'json') else response
                elif response.status_code == 429:  # Rate limit
                    time.sleep(delay * (2 ** attempt))
                    continue
                elif response.status_code == 401:
                    raise FlowiseAPIError("Authentication failed - check API key")
                elif response.status_code == 404:
                    raise FlowiseAPIError("Chatflow not found - check chatflow ID")
                else:
                    raise FlowiseAPIError(f"API error: {response.status_code}")
            
            return response
            
        except requests.exceptions.RequestException as e:
            if attempt == max_retries - 1:
                raise FlowiseAPIError(f"Request failed after {max_retries} attempts: {e}")
            time.sleep(delay * (2 ** attempt))
    
    raise FlowiseAPIError("Max retries exceeded")
```

## Best Practices

### 1. Configuration Management
- Store chatflow IDs in environment variables or secure configuration files
- Use different chatflows for different use cases (customer support, general chat, etc.)
- Implement chatflow routing based on user intent or message content

### 2. Security
- Always use HTTPS in production
- Rotate API keys regularly
- Implement proper CORS settings:
  ```
  CORS_ORIGINS=https://yourdomain.com
  IFRAME_ORIGINS=https://yourdomain.com
  ```

### 3. Performance Optimization
- Use streaming for better user experience with long responses
- Implement connection pooling for high-volume applications

- Cache chatflow metadata to reduce API calls